//Java笔记from Algorithm、leetcode、Java Project

General：
1、关于final关键字：final关键字可以用来修饰类、方法和变量
    A、修饰类
    　  当用final修饰一个类时，表明这个类不能被继承。也就是说，如果一个类你永远不会让他被继承，就可以用final进行修饰
    B、修饰方法
        当用final修饰一个方法时,父类的final方法是不能被子类所覆盖的，也就是说子类是不能够存在和父类一模一样的方法的
        因此，如果只有在想明确禁止该方法在子类中被覆盖的情况下才将方法设置为final
        父类private修饰的方法无法被子类继承，会隐式地被指定为final方法
    C、修饰变量
        final成员变量表示常量，只能被赋值一次，初始化后便不能发生变化。
        但是对于数组与HashMap而言，仅仅是final变量的指针不变而已。
        final HashMap<Integer,String> hm = new HashMap<>();
        //这句话会报错 hm = new HashMap<>();

来自Algorithm:
1、JAVA一般使用静态方法编辑自己的库，并且可以在每个类中添加main()方法用来测试各类用例。
2、停止输入流可以用command+d实现
3、Github不允许上传超过50MB的文件，过大会出错
4、JAVA当中也有泛型，用于实现模版API
5、可以在类的声明中加入<anything>,例如public class Bag<Item> implements Iterable<Item> {},即可在该类的方法中调用。
6、interface当中可以声明虚拟方法，不用声明public或者private
7、gitignore可以用于忽略配置文件与编译文件、gitattributes可以用来统计语言
8、可以利用public static方法定义类的静态变量，可以看作该类的全局变量，import该类之后就可以使用。
9、Collection的对象要用foreach来遍历集合对象，因为它实现了iterator遍历函数而不能用get方法

来自LeetCode_primary_level:
1、写好if...else if的逻辑关系很重要，全用if容易使数组越界，详见Insertion*;
2、A-Z是0x41-0x5a,a-z是0x61-7a,数字是0x30-0x39;
3、基本类型，值就直接保存在变量中；而引用类型，变量中保存的只是实际对象的地址。
   所以打印的时候直接打印字符串会直接打印一个地址而不是其内容
   对于基本类型，赋值运算符会直接改变变量的值，原来的值被覆盖掉。
   对于引用类型，赋值运算符会改变引用中所保存的地址，原来的地址被覆盖掉。但是原来的对象不会被改变。
   没有被任何引用所指向的对象是垃圾，会被垃圾回收器回收。
4、注意在结点的实际使用过程中容易出现java.lang.NullPointerException，如在Palindrome中的reverseList就是一个会报错的方法
5、递归方法在返回时是一次返回一个函数调用，而不是所有调用一次返回
6、除以二可以用>>1表示;左右相加L+R应该表示为((R-l) >> L)+l，详见LeetCode第一个错误的版本
7、递归在某些情况下会导致实践复杂度偏大，一般用动态规划降低复杂度。
8、在某些时候可以用Integer.MAX_VALUE表示最大的整型数，最小数同理。
9、栈的peek()操作可以不取出元素，而获得顶部元素。
10、数组下标从零开始是为了方便取得其物理地址，例如有指针base，其第一个元素的地址是0X4+base，其余同理。
11、ArrayList在初始化之前，不可以用set(i,5)方法提前指定某个元素的值，会报数组越界错误
12、可以调用异常处理方法处理某些难处理的问题，见isVaild
13、在Long类型转换为int类型时，用强制转换有时候会出错，见plusOne。

