//Java笔记from Algorithm、leetcode、Java Project

General：
1、关于final关键字：final关键字可以用来修饰类、方法和变量
    A、修饰类
    　  当用final修饰一个类时，表明这个类不能被继承。也就是说，如果一个类你永远不会让他被继承，就可以用final进行修饰
    B、修饰方法
        当用final修饰一个方法时,父类的final方法是不能被子类所覆盖的，也就是说子类是不能够存在和父类一模一样的方法的
        因此，如果只有在想明确禁止该方法在子类中被覆盖的情况下才将方法设置为final
        父类private修饰的方法无法被子类继承，会隐式地被指定为final方法
    C、修饰变量
        final成员变量表示常量，只能被赋值一次，初始化后便不能发生变化。
        但是对于数组与HashMap而言，仅仅是final变量的指针不变而已。
        final HashMap<Integer,String> hm = new HashMap<>();
        //这句话会报错 hm = new HashMap<>();
2、关于static关键字：
    A、static变量：静态变量在装载类的时候被分配内存并且初始化，而类只能被装载一次，所以此变量只有一份拷贝
    B、static方法：静态方法也只有一个拷贝，同时不需要创建类的实例，可以通过类名直接访问,同时，静态方法不存在运行时多态。
    C、static块：静态初始化块，类中不同的静态块按它们在类中出现的顺序 被依次执行。
    D、this关键字引用当前实例，所以在static方法中不能使用this关键字。

来自Algorithm:
1、JAVA一般使用静态方法编辑自己的库，并且可以在每个类中添加main()方法用来测试各类用例。
2、停止输入流可以用command+d实现
3、Github不允许上传超过50MB的文件，过大会出错
4、JAVA当中也有泛型，用于实现模版API
5、可以在类的声明中加入<anything>,例如public class Bag<Item> implements Iterable<Item> {},即可在该类的方法中调用。
6、interface当中可以声明虚拟方法，不用声明public或者private
7、gitignore可以用于忽略配置文件与编译文件、gitattributes可以用来统计语言
8、可以利用public static方法定义类的静态变量，可以看作该类的全局变量，import该类之后就可以使用。
9、Collection的对象要用foreach来遍历集合对象，因为它实现了iterator遍历函数而不能用get方法

来自LeetCode_primary_level:
1、写好if...else if的逻辑关系很重要，全用if容易使数组越界，详见Insertion*;
2、A-Z是0x41-0x5a,a-z是0x61-7a,数字是0x30-0x39;
3、基本类型，值就直接保存在变量中；而引用类型，变量中保存的只是实际对象的地址。
   所以打印的时候直接打印字符串会直接打印一个地址而不是其内容
   对于基本类型，赋值运算符会直接改变变量的值，原来的值被覆盖掉。
   对于引用类型，赋值运算符会改变引用中所保存的地址，原来的地址被覆盖掉。但是原来的对象不会被改变。
   没有被任何引用所指向的对象是垃圾，会被垃圾回收器回收。
4、注意在结点的实际使用过程中容易出现java.lang.NullPointerException，如在Palindrome中的reverseList就是一个会报错的方法
5、递归方法在返回时是一次返回一个函数调用，而不是所有调用一次返回
6、除以二可以用>>1表示;左右相加L+R应该表示为((R-l) >> L)+l，详见LeetCode第一个错误的版本
7、递归在某些情况下会导致实践复杂度偏大，一般用动态规划降低复杂度。
8、在某些时候可以用Integer.MAX_VALUE表示最大的整型数，最小数同理。
9、栈的peek()操作可以不取出元素，而获得顶部元素。
10、数组下标从零开始是为了方便取得其物理地址，例如有指针base，其第一个元素的地址是0X4+base，其余同理。
11、ArrayList在初始化之前，不可以用set(i,5)方法提前指定某个元素的值，会报数组越界错误
12、可以调用异常处理方法处理某些难处理的问题，见isVaild
13、在Long类型转换为int类型时，用强制转换有时候会出错，见plusOne。

Java考试复习：
1、Java中package与import语句不能调换
2、Java的字符集是16位unicode，其中byte、short、int、long类型分别占用1、2、4、8个字节，double类型占用8，float占用4字节。
3、String args[]是指的编译时的系统参数
4、Java把数据分为基本与引用类型，Java参数，不管是原始类型还是引用类型， 都是传值。
    基本类型为：整形(byte、short、int、long)、浮点型(float、double)、字符(char)、布尔(boolean)
    引用类型为：类、接口、数组
5、运行时数据区：堆区、栈区、方法区
    堆区：JVM只有一个堆区，用于存储对象，并且不存放基本类型与对象引用，只存放对象本身，包括数组，堆中的内存块是动态分配的，
          可以安任意顺序分配与释放。
    栈区：每一个线程都有一个栈区，栈区之存放基本数据类型与对象的引用
    方法区：包含所有的class类型与static变量，所有线程共享。
6、考试的时候要小心看if...else语句，可能这个地方会出一个脑筋急转弯
7、有关switch语句：
    case后面可以跟多个语句，这些语句可以不用大括号括起来
    switch语句判断条件可接受int, byte, char, short型，不可以接受其他类型
    一旦碰到第一次case匹配，就会开始顺序执行以后所有的程序代码，而不管后面的case条件是否匹配，
    后面case条件下的代码都会被执行，直到碰到break语句为止
8、创建数组时，如果没有给初始值：
    基本类型数值数据，默认的初始值为0
    boolean类型数据，默认值为false;
    引用类型元素的默认值为null
    初始化时，还可以用
    int monthDays[];
    monthDays =new int[]{ 31,28,31,30,31,30,31,31,30,31,30,31};
9、方法签名包括方法名与参数列表，方法签名不一样的方法不是一个方法。
10、在 for 体内声明的变量，其作用域只限于循环体内
11、Java为数据域(每个类定义的变量)都会分配默认值，而不会为每个方法分配默认值：
    引用类型数据域的默认值为 null
    数值类型数据域 的默认值为0
    boolean 类型的默认值为false
    而 char类型的默认值为‘\u0000’
12、为什么数据域应该是非公开的? 1.保护数据2.易于维护类。
13、类的继承：区别在于在不同包中，子类无法继承父类的默认访问级别的变量与方法。
    当子类和父类位于同一个包中:子类继承父类中public、protected和*默认访问级别*的成员变量和成员方法
    当子类和父类位于不同的包中:子类继承父类中public和protected访问级别的成员变量和成员方法
14、有关多态：在程序中统一符号或名字在不同情况下具有不同解释的现象称为多态。
    多态分为两种：
    编译时多态：静态绑定，主要、通过方法重载机制获得
    运行时多态：动态绑定，主要通过类继承与动态绑定机制获得，Java允许祖先类引用后代的对象实例
    以下语句是合法的：
        Father father = new Son();
        Father father2 = father;//其中father是Father的指针，Son的实例
15、this关键字：当一个对象创建后，JVM就会给这个对象分配一个引用自身的指针，这个指针的名字就是this。
    因此，this只能在类中的 非静态方法中使用，静态方法和静态的代码块中不能出现this。
    this只和特定的对象关联，而不和类关联，同一个类的不同对象有不同的this。
16、super关键字：调用super关键字的时机：
    1.在类的构造方法中，通过super语句调用这个类的父类的构造方法
    2.在子类中访问父类的被屏蔽的方法和属性。
    3.只能在构造方法或实例方法内使用super关键字，而在静态方法和静态代码块内不能使用super关键字
    4.如果父类中的成员变量和方法被定义为private类型，那么子类无法访问它们，
      如果试图采用super.var的形式去访问父类的private类型的var变量，就会导致编译错误。
17、多个线程有各自的调用栈，自己的寄存器环境，自己的线程本地存储，
18、Java线程通过继承Thread类或者实现Runnable接口实现，Java的线程提供一个优先级，抢占式，分时的线程调度。
19、在多线程中，可以使用volatile关键字，使得变量可以多线程共享，􏰓􏰌􏰋􏰃􏰅􏰎􏰋􏰂只保证单个变量的可见性，不保证原子性，对于赋值操作安全，对于++不安全
20、可以用synchronized(this){}加锁，以降低琐的粒度，降低同步粒度是消除死锁最有效的方法
21、Java的IO流可以分为字节流和字符流，字节流是8位不方便处理unicode信息，字符流(char)用于处理16位unicode信息
22、InputStream与OutStream类是所有输入输出流的父类，它是一个抽象类，不能被实例化，read()、write()方法都是系统调用，由系统实现
23、IO访问文件的方式：标准访问、直接IO、同步访问、异步访问(线程不会阻塞等待IO完成)、内存映射。文件是操作系统和磁盘交互的一个最小单元。